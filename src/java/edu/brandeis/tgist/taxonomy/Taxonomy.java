package edu.brandeis.tgist.taxonomy;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.GZIPInputStream;

public class Taxonomy {

	/** The name of the properties file inside of the taxonomy directory. */
	public static final String PROPERTIES_FILE = "properties.txt";

	/** The name of the feature vectors file in the taxonomy directory. */
	public static final String FEATURES_FILE = "features.txt";

	/** The name of the technologies file in the taxonomy directory. */
	public static final String TECHNOLOGIES_FILE = "technologies.txt";

	/** The minimum technology score required for a term to be included. */
	public static float TECHSCORE = 0.5f;

	/** The minimum term count required for a term to be included. */
	public static int MINCOUNT = 2;

	// TODO: allow changing TECHSCORE and MINCOUNT in the calling method and add
	// the values chosen to the properties file

	public String name;
	public String location;
	public HashMap<String, Technology> technologies;
	public List<FeatureVector> features;

	/**
	 * Create a new taxonomy. Creates a new directory and initializes the taxonomy,
	 * which includes writing a properties file.
	 *
	 * @param taxonomyName Name of the taxonomy.
	 * @param taxonomyLocation Location of the taxonomy.
	 * @throws java.io.IOException
	 */
	public Taxonomy(String taxonomyName, String taxonomyLocation)
			throws IOException {

		if (Files.exists(Paths.get(taxonomyLocation))) {
			Logger.getLogger(Taxonomy.class.getName())
					.log(Level.WARNING,
							"a file or directory named \"{0}\" allready exists",
							taxonomyLocation);
			System.exit(0);
		}

		this.name = taxonomyName;
		this.location = taxonomyLocation;

		new File(taxonomyLocation).mkdirs();

		ArrayList<String> lines = new ArrayList<>();
		lines.add("name = " + taxonomyName);
		lines.add("location = " + taxonomyLocation);
		Files.write(
				Paths.get(taxonomyLocation + File.separator + PROPERTIES_FILE),
				lines, StandardCharsets.UTF_8);
	}

	/**
	 * Open an existing taxonomy.
	 *
	 * @param taxonomyLocation The location of the taxonomy.
	 * @throws java.io.FileNotFoundException
	 */
	public Taxonomy(String taxonomyLocation)
			throws FileNotFoundException, IOException {

		Properties properties;
		try (FileInputStream fi = new FileInputStream(
				taxonomyLocation +  File.separator + PROPERTIES_FILE)) {
			properties = new Properties();
			properties.load(fi);
		}
		this.name = properties.getProperty("name");
		this.location = taxonomyLocation;

		this.technologies = new HashMap<>();
		this.features = new ArrayList<>();

		String tFile = this.location + File.separator + TECHNOLOGIES_FILE;
		String vFile = this.location + File.separator + FEATURES_FILE;

		FileInputStream inputStream;
		Scanner sc;

		// reading the technologies in the taxonomy
		if (new File(tFile).isFile()) {
			System.out.println("Reading technologies...");
			inputStream = new FileInputStream(tFile);
			sc = new Scanner(inputStream, "UTF-8");
			while (sc.hasNextLine()) {
				String line = sc.nextLine();
				String[] fields = line.split("\t");
				String term = fields[0];
				float score = Float.parseFloat(fields[1]);
				int count = Integer.parseInt(fields[2]);
				this.technologies.put(term, new Technology(term, score, count));
			}
		}

		// reading the feature vectors in the taxonomy
		if (new File(vFile).isFile()) {
			System.out.println("Reading features...");
			inputStream = new FileInputStream(vFile);
			sc = new Scanner(inputStream, "UTF-8");
			while (sc.hasNextLine()) {
				String line = sc.nextLine();
				this.features.add(new FeatureVector(line));
			}
		}
	}

	@Override
	public String toString() {
		return String.format("<taxonomy.Taxonomy %s terms=%d features=%d>",
				this.name, this.technologies.size(), this.features.size());
	}

	public void prettyPrint() {
		System.out.println(this);
		for (int i = 0; i < 5 && i < this.features.size(); i++)
			System.out.println("   " + this.features.get(i));
	}

	/**
	 * Add data to a taxonomy.
	 *
	 * This is really just for the initialization and adding subsequent data will
	 * probably be done in another way. The terms file is a file as generated by
	 * the tgist-classifiers code and the features file is a file generated by the
	 * tgist-features code (more specifically, by the extract_features.py script).
	 *
	 * @param termsFile
	 * @param featuresFile
	 * @throws IOException
	 */
	public void importData(String termsFile, String featuresFile)
			throws IOException {

		importTechnologies(termsFile);
		importFeatures(featuresFile);
		writeData();
	}

	/**
	 * Read and add technologies from a file with terms.
	 *
	 * The input file includes the normalized term name (all lower case), the
	 * term count and the technology score. This file is external to the taxonomy
	 * and the terms in the file will be added to the taxonomy if the terms meet
	 * a few conditions on minimal frequency and minimal technology score.
	 *
	 * @param termsFile
	 * @throws FileNotFoundException
	 * @throws UnsupportedEncodingException
	 * @throws IOException
	 */
	private void importTechnologies(String termsFile)
			throws FileNotFoundException, UnsupportedEncodingException, IOException {

		FileInputStream fileStream = new FileInputStream(termsFile);
		Reader decoder = new InputStreamReader(fileStream, StandardCharsets.UTF_8);
		BufferedReader reader = new BufferedReader(decoder);
		String line;
		while ((line = reader.readLine()) != null) {
			String[] fields = line.split("\t");
			String term = fields[0];
			float score = Float.parseFloat(fields[1]);
			int count = Integer.parseInt(fields[2]);
			if (score >= TECHSCORE && count >= MINCOUNT) {
				Technology ti = new Technology(term, score, count);
		        this.technologies.put(term, ti);
			}
		}
		System.out.println(
				String.format("Loaded %d technologies", this.technologies.size()));
	}

	/**
	 * Read and add feature vectors.
	 *
	 * Only read the vectors for terms that occur in the technologies map. The
	 * vectors are read from a file that is external to the taxonomy and they
	 * are added if the vector is for a term that occurs in the taxonomy as a
	 * technology. The vectors are assumed to be in a gzipped file.
	 *
	 * @param featuresFile
	 * @throws IOException
	 */
	private void importFeatures(String featuresFile) throws IOException {

		BufferedReader buffered = getGzipReader(featuresFile);
		String line;
		String filename = null; //, year = null, term = null;
		int c = 0;
		while ((line = buffered.readLine()) != null) {
			c++;
			//if (c > 100_000) break;
			String[] fields = line.split("\t");
			if ("".equals(fields[0])) {
				String term = fields[3];
				if (this.technologies.containsKey(term)) {
					// prepend the full filename because the vector initialization
					// code expects that
					this.features.add(new FeatureVector(filename + line)); }
			} else {
				filename = fields[0];
			}
		}
		System.out.println(String.format("Loaded %d vectors", this.features.size()));
	}

	/**
	 * Utility to help read a gzipped file.
	 *
	 * @param fileName
	 * @return A BufferedReader
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	private BufferedReader getGzipReader(String fileName)
			throws FileNotFoundException, IOException {
		FileInputStream fileStream = new FileInputStream(fileName);
		InputStream gzipStream = new GZIPInputStream(fileStream);
		Reader decoder = new InputStreamReader(gzipStream, StandardCharsets.UTF_8);
		BufferedReader reader = new BufferedReader(decoder);
		return reader;
	}

	/**
	 * Write the technologies and vectors to files in the taxonomy directory.
	 *
	 * @throws IOException
	 */
	private void writeData() throws IOException {

		File tFile = new File(this.location + File.separator + TECHNOLOGIES_FILE);
		File vFile = new File(this.location + File.separator + FEATURES_FILE);

		tFile.createNewFile();
		vFile.createNewFile();

		try (OutputStreamWriter writer =
				new OutputStreamWriter(
					new FileOutputStream(tFile), StandardCharsets.UTF_8)) {

			for (String technology : this.technologies.keySet()) {
				Technology tech = this.technologies.get(technology);
				writer.write(String.format("%s\t%f\t%d\n", technology, tech.score, tech.count));
			}
		}

		System.out.println(String.format("Wrote technologies to %s", tFile));

		try (OutputStreamWriter writer =
				new OutputStreamWriter(
					new FileOutputStream(vFile), StandardCharsets.UTF_8)) {

			for (FeatureVector vector : this.features) {
				writer.write(vector.asTabSeparatedFields());
			}
		}

		System.out.println(String.format("Wrote features to %s", vFile));
	}

	void rhhr() {
		Node top = new Node("Top");
		int c = 0;
		for (Technology tech : this.technologies.values()) {
			c++;
			if (c > 100) break;
			//System.out.println("\n" + tech.name);
			String[] tokens = tech.name.split(" ");
			top.insert(tech, tokens, tokens.length);
		}
		top.prettyPrint();
	}

}
